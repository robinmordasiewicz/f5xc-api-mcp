#!/usr/bin/env tsx

/**
 * Tool Generation Script
 *
 * Generates MCP tool definitions from F5 Distributed Cloud OpenAPI specifications.
 * This script is run after specs are synced to regenerate tool definitions.
 *
 * Generated files are automatically formatted with Prettier to ensure lint-compatible output.
 *
 * Usage:
 *   npm run generate
 *   tsx scripts/generate.ts
 */

import { existsSync, mkdirSync, writeFileSync, readFileSync } from "fs";
import { join, dirname } from "path";
import { fileURLToPath } from "url";
import * as prettier from "prettier";
import {
  parseSpecDirectory,
  getAllOperations,
  groupOperationsByDomain,
  ParsedOperation,
} from "../src/generator/openapi-parser.js";
import { generateToolName } from "../src/generator/naming/volterra-mapping.js";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

/**
 * Configuration
 */
const CONFIG = {
  /** Directory containing raw OpenAPI specs */
  SPECS_DIR: join(__dirname, "..", "specs", "raw"),

  /** Directory for generated tool definitions */
  GENERATED_DIR: join(__dirname, "..", "src", "tools", "generated"),

  /** Registry file for all tools */
  REGISTRY_FILE: join(__dirname, "..", "src", "tools", "registry.ts"),

  /** Tool index file */
  INDEX_FILE: join(__dirname, "..", "src", "tools", "index.ts"),
};

/**
 * Logger for script output
 */
const log = {
  info: (message: string): void => console.log(`[INFO] ${message}`),
  warn: (message: string): void => console.warn(`[WARN] ${message}`),
  error: (message: string): void => console.error(`[ERROR] ${message}`),
  success: (message: string): void => console.log(`[SUCCESS] ${message}`),
};

/**
 * Prettier configuration for generated TypeScript files
 */
const PRETTIER_CONFIG: prettier.Options = {
  parser: "typescript",
  semi: true,
  singleQuote: false,
  trailingComma: "es5",
  printWidth: 100,
  tabWidth: 2,
  useTabs: false,
};

/**
 * Format TypeScript code using Prettier
 */
async function formatCode(code: string): Promise<string> {
  try {
    return await prettier.format(code, PRETTIER_CONFIG);
  } catch (error) {
    log.warn(`Prettier formatting failed, using unformatted code: ${error instanceof Error ? error.message : String(error)}`);
    return code;
  }
}

/**
 * Write formatted TypeScript file
 */
async function writeFormattedFile(filePath: string, content: string): Promise<void> {
  const formattedContent = await formatCode(content);
  writeFileSync(filePath, formattedContent);
}

/**
 * Generate tool definition file for a domain
 */
function generateDomainFile(
  domain: string,
  operations: ParsedOperation[]
): string {
  const toolDefs = operations.map((op) => {
    return `  {
    toolName: "${op.toolName}",
    method: "${op.method}",
    path: "${op.path}",
    operation: "${op.operation}",
    domain: "${op.domain}",
    resource: "${op.resource}",
    summary: ${JSON.stringify(op.summary)},
    description: ${JSON.stringify(op.description)},
    pathParameters: ${JSON.stringify(op.pathParameters, null, 2).replace(/\n/g, "\n    ")},
    queryParameters: ${JSON.stringify(op.queryParameters, null, 2).replace(/\n/g, "\n    ")},
    requestBodySchema: ${op.requestBodySchema ? JSON.stringify(op.requestBodySchema, null, 2).replace(/\n/g, "\n    ") : "null"},
    responseSchema: ${op.responseSchema ? JSON.stringify(op.responseSchema, null, 2).replace(/\n/g, "\n    ") : "null"},
    requiredParams: ${JSON.stringify(op.requiredParams)},
    operationId: ${op.operationId ? `"${op.operationId}"` : "null"},
    tags: ${JSON.stringify(op.tags)},
    sourceFile: "${op.sourceFile}",
  }`;
  });

  return `/**
 * Generated tool definitions for ${domain} domain
 * DO NOT EDIT - This file is auto-generated by scripts/generate.ts
 */

import type { ParsedOperation } from "../../../generator/openapi-parser.js";

export const ${domain}Tools: ParsedOperation[] = [
${toolDefs.join(",\n")}
];

export default ${domain}Tools;
`;
}

/**
 * Generate the tool registry file
 */
function generateRegistryFile(domains: string[]): string {
  const imports = domains
    .map((d) => `import { ${d}Tools } from "./generated/${d}/index.js";`)
    .join("\n");

  const exports = domains.map((d) => `  ...${d}Tools,`).join("\n");

  return `/**
 * Tool Registry - All generated MCP tools
 * DO NOT EDIT - This file is auto-generated by scripts/generate.ts
 */

import type { ParsedOperation } from "../generator/openapi-parser.js";

${imports}

/**
 * All registered tools from all domains
 */
export const allTools: ParsedOperation[] = [
${exports}
];

/**
 * Get tools by domain
 */
export function getToolsByDomain(domain: string): ParsedOperation[] {
  return allTools.filter((tool) => tool.domain === domain);
}

/**
 * Get tool by name
 */
export function getToolByName(name: string): ParsedOperation | undefined {
  return allTools.find((tool) => tool.toolName === name);
}

/**
 * Get all domain names
 */
export function getAllDomains(): string[] {
  return [...new Set(allTools.map((tool) => tool.domain))];
}

/**
 * Get tool count by domain
 */
export function getToolCountByDomain(): Record<string, number> {
  const counts: Record<string, number> = {};
  for (const tool of allTools) {
    counts[tool.domain] = (counts[tool.domain] ?? 0) + 1;
  }
  return counts;
}

export default allTools;
`;
}

/**
 * Generate tools index file
 */
function generateIndexFile(): string {
  return `/**
 * Tools Module - Export all tool utilities
 * DO NOT EDIT - This file is auto-generated by scripts/generate.ts
 */

export {
  allTools,
  getToolsByDomain,
  getToolByName,
  getAllDomains,
  getToolCountByDomain,
} from "./registry.js";

export type { ParsedOperation } from "../generator/openapi-parser.js";
`;
}

/**
 * Main generation function
 */
async function generate(): Promise<void> {
  console.log("=".repeat(60));
  console.log("F5XC API MCP Tool Generator");
  console.log("=".repeat(60));

  // Check if specs exist
  if (!existsSync(CONFIG.SPECS_DIR)) {
    log.warn(`Specs directory not found: ${CONFIG.SPECS_DIR}`);
    log.info("Run 'npm run sync-specs' first to download OpenAPI specs");

    // Create placeholder files for empty state (formatted)
    mkdirSync(join(CONFIG.GENERATED_DIR, "core"), { recursive: true });
    await writeFormattedFile(
      join(CONFIG.GENERATED_DIR, "core", "index.ts"),
      generateDomainFile("core", [])
    );
    await writeFormattedFile(CONFIG.REGISTRY_FILE, generateRegistryFile(["core"]));
    await writeFormattedFile(CONFIG.INDEX_FILE, generateIndexFile());

    log.info("Created placeholder tool files (Prettier formatted)");
    return;
  }

  // Parse all specs
  log.info("Parsing OpenAPI specifications...");
  const specs = parseSpecDirectory(CONFIG.SPECS_DIR);

  if (specs.length === 0) {
    log.warn("No valid OpenAPI specs found");
    return;
  }

  log.info(`Found ${specs.length} spec files`);

  // Get all unique operations
  const operations = getAllOperations(specs);
  log.info(`Extracted ${operations.length} unique operations`);

  // Group by domain
  const domainGroups = groupOperationsByDomain(operations);
  const domains = Array.from(domainGroups.keys()).sort();

  log.info(`Domains: ${domains.join(", ")}`);

  // Generate domain files (formatted with Prettier)
  log.info("Generating and formatting tool files...");
  for (const [domain, ops] of domainGroups) {
    const domainDir = join(CONFIG.GENERATED_DIR, domain);
    mkdirSync(domainDir, { recursive: true });

    // Sort operations by toolName for deterministic output
    const sortedOps = [...ops].sort((a, b) => a.toolName.localeCompare(b.toolName));
    const content = generateDomainFile(domain, sortedOps);
    await writeFormattedFile(join(domainDir, "index.ts"), content);

    log.info(`Generated ${ops.length} tools for ${domain} domain`);
  }

  // Generate registry and index (formatted with Prettier)
  await writeFormattedFile(CONFIG.REGISTRY_FILE, generateRegistryFile(domains));
  await writeFormattedFile(CONFIG.INDEX_FILE, generateIndexFile());
  log.info("All generated files formatted with Prettier");

  // Summary
  console.log("=".repeat(60));
  console.log("Generation Summary:");
  console.log(`  Total operations: ${operations.length}`);
  console.log(`  Domains: ${domains.length}`);
  for (const [domain, ops] of domainGroups) {
    console.log(`    - ${domain}: ${ops.length} tools`);
  }
  console.log(`  Output directory: ${CONFIG.GENERATED_DIR}`);
  console.log("=".repeat(60));
  log.success("Generation complete!");
}

/**
 * Entry point
 */
generate()
  .then(() => {
    process.exit(0);
  })
  .catch((error: unknown) => {
    log.error(`Generation failed: ${error instanceof Error ? error.message : String(error)}`);
    process.exit(1);
  });
